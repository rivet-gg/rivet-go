// This file was auto-generated by Fern from our API Definition.

package matchmaker

import (
	fmt "fmt"
	uuid "github.com/google/uuid"
)

// Matchmaker captcha configuration.
type Captcha struct {
	// Denotes how many requests a connection can make before it is required to reverify a captcha.
	RequestsBeforeReverify int `json:"requests_before_reverify"`
	// Denotes how long a connection can continue to reconnect without having to reverify a captcha (in milliseconds).
	VerificationTtl int64             `json:"verification_ttl"`
	Hcaptcha        *CaptchaHcaptcha  `json:"hcaptcha,omitempty"`
	Turnstile       *CaptchaTurnstile `json:"turnstile,omitempty"`
}

// hCpatcha configuration.
type CaptchaHcaptcha struct {
	Level CaptchaHcaptchaLevel `json:"level,omitempty"`
}

// How hard a captcha should be.
type CaptchaHcaptchaLevel string

const (
	CaptchaHcaptchaLevelEasy      CaptchaHcaptchaLevel = "easy"
	CaptchaHcaptchaLevelModerate  CaptchaHcaptchaLevel = "moderate"
	CaptchaHcaptchaLevelDifficult CaptchaHcaptchaLevel = "difficult"
	CaptchaHcaptchaLevelAlwaysOn  CaptchaHcaptchaLevel = "always_on"
)

func NewCaptchaHcaptchaLevelFromString(s string) (CaptchaHcaptchaLevel, error) {
	switch s {
	case "easy":
		return CaptchaHcaptchaLevelEasy, nil
	case "moderate":
		return CaptchaHcaptchaLevelModerate, nil
	case "difficult":
		return CaptchaHcaptchaLevelDifficult, nil
	case "always_on":
		return CaptchaHcaptchaLevelAlwaysOn, nil
	}
	var t CaptchaHcaptchaLevel
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CaptchaHcaptchaLevel) Ptr() *CaptchaHcaptchaLevel {
	return &c
}

// Turnstile captcha configuration.
type CaptchaTurnstile struct {
	SiteKey   string `json:"site_key"`
	SecretKey string `json:"secret_key"`
}

type NetworkMode string

const (
	NetworkModeBridge NetworkMode = "bridge"
	NetworkModeHost   NetworkMode = "host"
)

func NewNetworkModeFromString(s string) (NetworkMode, error) {
	switch s {
	case "bridge":
		return NetworkModeBridge, nil
	case "host":
		return NetworkModeHost, nil
	}
	var t NetworkMode
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (n NetworkMode) Ptr() *NetworkMode {
	return &n
}

// A port protocol.
type PortProtocol string

const (
	PortProtocolHttp   PortProtocol = "http"
	PortProtocolHttps  PortProtocol = "https"
	PortProtocolTcp    PortProtocol = "tcp"
	PortProtocolTcpTls PortProtocol = "tcp_tls"
	PortProtocolUdp    PortProtocol = "udp"
)

func NewPortProtocolFromString(s string) (PortProtocol, error) {
	switch s {
	case "http":
		return PortProtocolHttp, nil
	case "https":
		return PortProtocolHttps, nil
	case "tcp":
		return PortProtocolTcp, nil
	case "tcp_tls":
		return PortProtocolTcpTls, nil
	case "udp":
		return PortProtocolUdp, nil
	}
	var t PortProtocol
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p PortProtocol) Ptr() *PortProtocol {
	return &p
}

// Range of ports that can be connected to.
type PortRange struct {
	// Unsigned 32 bit integer.
	Min int `json:"min"`
	// Unsigned 32 bit integer.
	Max int `json:"max"`
}

type ProxyKind string

const (
	ProxyKindNone      ProxyKind = "none"
	ProxyKindGameGuard ProxyKind = "game_guard"
)

func NewProxyKindFromString(s string) (ProxyKind, error) {
	switch s {
	case "none":
		return ProxyKindNone, nil
	case "game_guard":
		return ProxyKindGameGuard, nil
	}
	var t ProxyKind
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p ProxyKind) Ptr() *ProxyKind {
	return &p
}

// A game mode.
type GameMode struct {
	Regions                map[string]*GameModeRegion `json:"regions,omitempty"`
	MaxPlayers             *int                       `json:"max_players,omitempty"`
	MaxPlayersDirect       *int                       `json:"max_players_direct,omitempty"`
	MaxPlayersParty        *int                       `json:"max_players_party,omitempty"`
	Docker                 *GameModeRuntimeDocker     `json:"docker,omitempty"`
	Listable               *bool                      `json:"listable,omitempty"`
	Taggable               *bool                      `json:"taggable,omitempty"`
	AllowDynamicMaxPlayers *bool                      `json:"allow_dynamic_max_players,omitempty"`
	Actions                *GameModeActions           `json:"actions,omitempty"`
	Tier                   *string                    `json:"tier,omitempty"`
	IdleLobbies            *GameModeIdleLobbiesConfig `json:"idle_lobbies,omitempty"`
}

// Configuration for the connection types allowed for a game mode.
type GameModeActions struct {
	Find   *GameModeFindConfig   `json:"find,omitempty"`
	Join   *GameModeJoinConfig   `json:"join,omitempty"`
	Create *GameModeCreateConfig `json:"create,omitempty"`
}

// Configures the requirements and authentication for the /create endpoint. If this value is not set in the config, the /create endpoint is NOT enabled.
type GameModeCreateConfig struct {
	// Sets whether or not the /create endpoint is enabled.
	Enabled             bool                         `json:"enabled"`
	IdentityRequirement *GameModeIdentityRequirement `json:"identity_requirement,omitempty"`
	Verification        *GameModeVerificationConfig  `json:"verification,omitempty"`
	// Defaults to false when unset.
	EnablePublic *bool `json:"enable_public,omitempty"`
	// Defaults to true when unset.
	EnablePrivate         *bool `json:"enable_private,omitempty"`
	MaxLobbiesPerIdentity *int  `json:"max_lobbies_per_identity,omitempty"`
}

// Configures the requirements and authentication for the /find endpoint. If this value is not set in the config, the /find endpoint is still enabled.
type GameModeFindConfig struct {
	// Sets whether or not the /find endpoint is enabled.
	Enabled             bool                         `json:"enabled"`
	IdentityRequirement *GameModeIdentityRequirement `json:"identity_requirement,omitempty"`
	Verification        *GameModeVerificationConfig  `json:"verification,omitempty"`
}

// The registration requirement for a user when joining/finding/creating a lobby. "None" allows for connections without an identity.
type GameModeIdentityRequirement string

const (
	GameModeIdentityRequirementNone       GameModeIdentityRequirement = "none"
	GameModeIdentityRequirementGuest      GameModeIdentityRequirement = "guest"
	GameModeIdentityRequirementRegistered GameModeIdentityRequirement = "registered"
)

func NewGameModeIdentityRequirementFromString(s string) (GameModeIdentityRequirement, error) {
	switch s {
	case "none":
		return GameModeIdentityRequirementNone, nil
	case "guest":
		return GameModeIdentityRequirementGuest, nil
	case "registered":
		return GameModeIdentityRequirementRegistered, nil
	}
	var t GameModeIdentityRequirement
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GameModeIdentityRequirement) Ptr() *GameModeIdentityRequirement {
	return &g
}

// Configuration for how many idle lobbies a game version should have.
type GameModeIdleLobbiesConfig struct {
	Min int `json:"min"`
	Max int `json:"max"`
}

// Configures the requirements and authentication for the /join endpoint. If this value is not set in the config, the /join endpoint is still enabled.
type GameModeJoinConfig struct {
	// Sets whether or not the /join endpoint is enabled.
	Enabled             bool                         `json:"enabled"`
	IdentityRequirement *GameModeIdentityRequirement `json:"identity_requirement,omitempty"`
	Verification        *GameModeVerificationConfig  `json:"verification,omitempty"`
}

// A game mode region.
type GameModeRegion struct {
	Tier        *string                    `json:"tier,omitempty"`
	IdleLobbies *GameModeIdleLobbiesConfig `json:"idle_lobbies,omitempty"`
}

// A game mode runtime running through Docker.
type GameModeRuntimeDocker struct {
	// _Configures Rivet CLI behavior. Has no effect on server behavior._
	Dockerfile *string `json:"dockerfile,omitempty"`
	// _Configures Rivet CLI behavior. Has no effect on server behavior._
	Image       *string                               `json:"image,omitempty"`
	ImageId     *uuid.UUID                            `json:"image_id,omitempty"`
	Args        []string                              `json:"args,omitempty"`
	Env         map[string]string                     `json:"env,omitempty"`
	NetworkMode *NetworkMode                          `json:"network_mode,omitempty"`
	Ports       map[string]*GameModeRuntimeDockerPort `json:"ports,omitempty"`
}

// A docker port.
type GameModeRuntimeDockerPort struct {
	// The port number to connect to.
	Port      *int          `json:"port,omitempty"`
	PortRange *PortRange    `json:"port_range,omitempty"`
	Protocol  *PortProtocol `json:"protocol,omitempty"`
	// How this port should be proxied. Defaults to 'game-guard`.
	Proxy *ProxyKind `json:"proxy,omitempty"`
	// _Configures Rivet CLI behavior. Has no effect on server behavior._
	DevPort *int `json:"dev_port,omitempty"`
	// _Configures Rivet CLI behavior. Has no effect on server behavior._
	DevPortRange *PortRange `json:"dev_port_range,omitempty"`
	// _Configures Rivet CLI behavior. Has no effect on server behavior._
	DevProtocol *PortProtocol `json:"dev_protocol,omitempty"`
}

// Configuration that tells Rivet where to send validation requests and with what headers. When set, Rivet will send the `verification_data` property (given by the user in the find/join/create endpoint) to the given url along with the headers provided and some information about the requested lobby. The response of this request will determine if the user can join that lobby or not.
type GameModeVerificationConfig struct {
	Url     string            `json:"url"`
	Headers map[string]string `json:"headers,omitempty"`
}

// A game mode.
type LobbyGroup struct {
	// **Deprecated: use GameMode instead**
	// A human readable short identifier used to references resources. Different than a `rivet.common#Uuid` because this is intended to be human readable. Different than `rivet.common#DisplayName` because this should not include special characters and be short.
	NameId string `json:"name_id"`
	// A list of game mode regions.
	Regions []*LobbyGroupRegion `json:"regions,omitempty"`
	// Unsigned 32 bit integer.
	MaxPlayersNormal int `json:"max_players_normal"`
	// Unsigned 32 bit integer.
	MaxPlayersDirect int `json:"max_players_direct"`
	// Unsigned 32 bit integer.
	MaxPlayersParty int                `json:"max_players_party"`
	Runtime         *LobbyGroupRuntime `json:"runtime,omitempty"`
}

// **Deprecated: use GameMode instead**
// Configuration for how many idle lobbies a game version should have.
type LobbyGroupIdleLobbiesConfig struct {
	// Unsigned 32 bit integer.
	MinIdleLobbies int `json:"min_idle_lobbies"`
	// Unsigned 32 bit integer.
	MaxIdleLobbies int `json:"max_idle_lobbies"`
}

// **Deprecated: use GameMode instead**
// A game mode region.
type LobbyGroupRegion struct {
	RegionId uuid.UUID `json:"region_id"`
	// A human readable short identifier used to references resources. Different than a `rivet.common#Uuid` because this is intended to be human readable. Different than `rivet.common#DisplayName` because this should not include special characters and be short.
	TierNameId  string                       `json:"tier_name_id"`
	IdleLobbies *LobbyGroupIdleLobbiesConfig `json:"idle_lobbies,omitempty"`
}

// **Deprecated: use GameMode instead**
// A union representing the runtime a game mode runs on.
type LobbyGroupRuntime struct {
	Docker *LobbyGroupRuntimeDocker `json:"docker,omitempty"`
}

// **Deprecated: use GameMode instead**
// A game mode runtime running through Docker.
type LobbyGroupRuntimeDocker struct {
	BuildId     *uuid.UUID                       `json:"build_id,omitempty"`
	Args        []string                         `json:"args,omitempty"`
	EnvVars     []*LobbyGroupRuntimeDockerEnvVar `json:"env_vars,omitempty"`
	NetworkMode *NetworkMode                     `json:"network_mode,omitempty"`
	Ports       []*LobbyGroupRuntimeDockerPort   `json:"ports,omitempty"`
}

// **Deprecated: use GameMode instead**
// A docker environment variable.
type LobbyGroupRuntimeDockerEnvVar struct {
	Key   string `json:"key"`
	Value string `json:"value"`
}

// **Deprecated: use GameMode instead**
// A docker port.
type LobbyGroupRuntimeDockerPort struct {
	// The label of this docker port.
	Label string `json:"label"`
	// The port number to connect to.
	TargetPort    *int         `json:"target_port,omitempty"`
	PortRange     *PortRange   `json:"port_range,omitempty"`
	ProxyProtocol PortProtocol `json:"proxy_protocol,omitempty"`
}

// Matchmaker configuration for a given version.
type Config struct {
	// A list of game modes.
	GameModes map[string]*GameMode `json:"game_modes,omitempty"`
	Captcha   *Captcha             `json:"captcha,omitempty"`
	// _Configures Rivet CLI behavior. Has no effect on server behavior._
	DevHostname      *string                    `json:"dev_hostname,omitempty"`
	Regions          map[string]*GameModeRegion `json:"regions,omitempty"`
	MaxPlayers       *int                       `json:"max_players,omitempty"`
	MaxPlayersDirect *int                       `json:"max_players_direct,omitempty"`
	MaxPlayersParty  *int                       `json:"max_players_party,omitempty"`
	Docker           *GameModeRuntimeDocker     `json:"docker,omitempty"`
	Tier             *string                    `json:"tier,omitempty"`
	IdleLobbies      *GameModeIdleLobbiesConfig `json:"idle_lobbies,omitempty"`
	// **Deprecated: use `game_modes` instead**
	// A list of game modes.
	LobbyGroups []*LobbyGroup `json:"lobby_groups,omitempty"`
}
